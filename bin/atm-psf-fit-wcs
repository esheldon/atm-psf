#!/usr/bin/env python
# TODO clean up

import fitsio
import galsim
from galsim import degrees
import numpy as np
import matplotlib.pyplot as mplt
# import esutil as eu
from esutil.stat import print_stats
# from glob import glob
from atm_psf.wcs import fit_gs_wcs, get_wcs_non_outliers, gs_wcs_to_dm_wcs
from lsst.meas.extensions.piff.piffPsfDeterminer import CelestialWcsWrapper

SCALE = 0.2


def get_args():
    import argparse
    parser = argparse.ArgumentParser()
    parser.add_argument('--image', required=True)
    parser.add_argument('--truth', required=True)
    parser.add_argument('--output', help='write a new image with updated wcs')

    args = parser.parse_args()

    assert args.image != args.output
    assert args.truth != args.output
    return args


def get_dm_xy(wcs, ra, dec):
    import lsst.geom
    x = np.zeros(ra.size)
    y = np.zeros(ra.size)

    for i in range(ra.size):
        skypos = lsst.geom.SpherePoint(ra[i], dec[i], lsst.geom.degrees)
        impos = wcs.skyToPixel(skypos)
        x[i] = impos.x
        y[i] = impos.y

    return x, y


def read_data(args):
    print('reading:', args.image)
    gsim = galsim.fits.read(args.image)
    print('reading:', args.truth)
    t = fitsio.read(args.truth)

    w, = np.where(
        np.isfinite(t['x']) & np.isfinite(t['y'])
    )

    t = t[w]
    return gsim, t


def plot_quiver(x, y, dx_arcsec, dy_arcsec, fname):
    fig, ax = mplt.subplots(figsize=(6, 5))
    ax.set(
        xlim=[-200, 4500],
        ylim=[-200, 4500],
    )
    M = np.sqrt(dx_arcsec**2 + dy_arcsec**2)

    cmap = 'inferno'
    qplt = ax.quiver(
        x, y, dx_arcsec, dy_arcsec,
        M,
        angles='xy',
        scale_units='xy',
        scale=0.0005,
        # scale=0.005,
        cmap=cmap,
    )
    fig.colorbar(qplt, cmap=cmap)
    print('saving:', fname)
    mplt.savefig(fname)
    if '.pdf' in fname:
        png = fname.replace('.pdf', '.png')
        print('saving:', png)
        mplt.savefig(png, dpi=150)


def main():
    args = get_args()

    rng = np.random.default_rng(1234)

    gsim, t = read_data(args)
    w, = np.where(t['phot_flux'] > 100)
    t = t[w]

    x = t['x']
    y = t['y']
    ra = t['ra']
    dec = t['dec']
    # x = t['xbat']
    # y = t['ybat']

    r = rng.uniform(size=t.size)
    s = r.argsort()

    # training and validation
    validation_frac = 0.5
    nvalidation = int(s.size * validation_frac)

    # verification
    vi = s[:nvalidation]
    # training
    ti = s[nvalidation:]

    order = 3
    nsig = 4
    wcs = fit_gs_wcs(orig_gs_wcs=gsim.wcs, truth=t[ti], nsig=nsig, order=order)
    dmwcs = gs_wcs_to_dm_wcs(wcs, gsim.bounds)
    # dmwcs = CelestialWcsWrapper(wcs)

    wgood, _, _ = get_wcs_non_outliers(wcs=wcs, data=t[vi], nsig=nsig)

    vi = vi[wgood]

    dmx, dmy = get_dm_xy(dmwcs, ra[vi], dec[vi])
    dmx += 1
    dmy += 1
    # dmx, dmy = dmwcs.radecToxy(
    #     ra=t['ra'][vi], dec=t['dec'][vi], units=degrees,
    # )
    # import IPython; IPython.embed()

    pra, pdec = wcs.xyToradec(
        x=x[vi],
        y=y[vi],
        units=degrees,
    )
    px, py = wcs.radecToxy(
        ra=ra[vi],
        dec=dec[vi],
        units=degrees,
    )
    dx = (px - x[vi])
    dy = (py - y[vi])
    ddec = (pdec - t['dec'][vi]) * 3600

    dmdx = (dmx - x[vi])
    dmdy = (dmy - y[vi])
    # import IPython; IPython.embed()

    if True:
        plot_quiver(x[vi], y[vi], dx * SCALE, dy * SCALE, fname='quiver.pdf')

    print('dx stats in arcsec')
    print_stats(dx * SCALE, nsig=4.5)
    print('dy stats in arcsec')
    print_stats(dy * SCALE, nsig=4.5)
    print('ddec stats in arcsec')
    print_stats(ddec, nsig=4.5)

    print('DM dx stats in arcsec')
    print_stats(dmdx * SCALE, nsig=4.5)
    print('DM dy stats in arcsec')
    print_stats(dmdy * SCALE, nsig=4.5)

    fig, axs = mplt.subplots(ncols=2, figsize=(8, 4))
    axs[0].set(
        xlabel=r'$\Delta$ x [arcsec]',
    )
    axs[1].set(
        xlabel=r'$\Delta$ DEC [arcsec]',
    )

    nbin = 30
    bins = np.linspace(-0.1, 0.1, nbin)
    # bins = nbin

    alpha = 0.5
    axs[0].hist(
        dx * SCALE,
        bins=bins,
        alpha=alpha,
        label='x',
    )
    axs[0].hist(
        dy * SCALE,
        bins=bins,
        alpha=alpha,
        label='y',
    )
    axs[0].legend()

    axs[1].hist(
        ddec,
        bins=bins,
        alpha=alpha,
        label='DEC',
    )
    axs[1].legend()

    fname = 'diffs.pdf'
    png_fname = 'diffs.png'
    print('writing:', fname)
    fig.savefig(fname)
    print('writing:', png_fname)
    fig.savefig(png_fname, dpi=150)
    # pplt.show()

    if args.output is not None:
        new_header = {}

        wcs.writeToFitsHeader(new_header, gsim.bounds)
        del new_header['GS_XMIN']
        del new_header['GS_YMIN']
        del new_header['GS_WCS']
        print('writing:', args.output)
        fitsio.write(args.output, gsim.array, header=new_header, clobber=True)


main()
